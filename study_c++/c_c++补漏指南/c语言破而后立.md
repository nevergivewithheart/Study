# c语言破而后立

## 一、c语言基础

### 1、C程序的组成与编译
#### 1.1 C程序的基本组成

> c程序主要包括以下部分：
>
> - 预处理指令
> - 函数
> - 变量
> - 语句 & 表达式
> - 注释

#### 1.2 C程序的编译与运行

> c语言一般采用gcc编译器进行编译。
>
> - GCC(全拼GUN Compiler Collection)是GNU工具链的主要组成部分，是一套以GPL和LGPL许可证发布的程序语言编译器自由软件。
> - GCC过程包括四个阶段：预处理（pre_processing）、编译（compiling）、汇编（assembling）以及链接（linking）

<img src=".\src\c语言编译过程.png" alt="从编译到可执行文件过程" style="zoom:70%;" />

| 后缀             | 描述                  | 后缀     | 描述           |
| ---------------- | --------------------- | -------- | -------------- |
| .c               | c源文件               | .s       | 汇编语言源文件 |
| .c/.cc/.cxx/.cpp | c++源文件             | .o/.obj  | 目标文件       |
| .h               | c/c++头文件           | .a/.lib  | 静态库         |
| .i/.ii           | 经过预处理的c/c++文件 | .so/.dll | 动态库         |

#### 1.3   gcc 编译指令

##### 1.3.1  常见的编译选项

1、无选项编译

``` shell
#假设test.c为源程序文件
gcc test.c
# 作用：未指定输出文件，默认输出文件为a.out
```

2、选项 - o

``` shell
# -o 选项用来指定输出的文件文件名
gcc test.c -o test
```

3、选项-E

``` shell
#将源文件预处理输出件
gcc -E test.c -o test.i
```

### 2. Linux系统基本操作
#### 1.1 Linux基础（启动过程）
> Linux系统启动过程是指从用户开机、通电到可以输入用户名和密码登录系统的过程。
> 启动的过程有了两个阶段：
> 1、电脑加电，BIOS自检。
> 2、执行GRUB引导->加载Linux内核->执行init程序进行初始化->等待用户登录

> 当自检通过时，就会进入硬盘的MRB（主引导记录）中执行存储在该区的程序（即Linux系统中的grub程序【系统引导程序】）。该程序的主要作用就是确定存储在硬盘中的操作系统从什么地方启动。配置文件/boot/grub/grub.conf在硬盘中记载所有操作系统以及操作系统的存储信息。

>在选择了合适的操作系统之后就启动init服务对操作系统进行初始化。启动init服务实际上是执行init程序**该程序Linux系统运行的第一个程序，也是运行的第一个进程**。该程序根据启动模式确定如歌启动系统。

系统差异：
- Ubuntu中的init进程不会直接去目录文件/etc/init.d或者/etc/rc${runlevel}.d/中查找相应的文件执行；
- 采用折衷的方式，通过/etc/init下的相应配置文件来调用/etc/rc${runlevel}.d/中的脚本以启动，采用旧式System V-style的服务。
- Ubuntu系统的启动文件存在三个目录中：/etc/init 、/etc/init.d、/etc/rc${runlevel}.d
- Ubuntu系统的启动模式分为七种，一般情况，采用的runlevel为1，3，5三种启动模式，启动模式0和6一般不会设为启动模式，否则在开机以后就会直接关机或者重启无法正常使用系统。

//TODO:(不同模式之间的差别)

#### 1.2 Linux文件系统基础

### 3.Linux编程基础

## 二、c语言提高

### 1、字节对齐

> 数据对齐的问题，为了让数据结构以最优的方式存储、处理，保证读写数据都一一对齐，往往采用3中方式：
>
> - 手动对齐，将数据按从小到大的顺序对齐，尽量凑齐；
>
> - 使用# pragma pack（n） 指定数据结构的对齐的值（成对使用）
>
>   ```c++
>   #pragma pack(1)
>   struct test
>   {
>    char a;
>    int b;
>   }
>   #pragma pack()
>     
>   sizeof(test)==5
>    
>       
>   struct test2
>   {
>    char a;
>    int b;
>   } 
>   ```
>
> - 使用 \__attribute__((packed)),让编译器取消结构在编译过程中的优化对齐，按照实际占用的字节数进行对齐，两边都使用该方式取消优化对齐。就不会出现对齐的错位现象；

### 2、结构体的使用









###  3、函数指针

```c
//定义形式：返回类型 （*指针变量名）（参数类型1，参数类型2，.....） 
int(*p)(int a,int b);
//调用形式  指针变量名（参数）
int c = p(1,2);
```



### 4、命令行参数

```c
int main(int argc,char* argv[])
{
    ...
}
```

> - **argc:**代表启动程序时，命令行参数的个数。c/c++语言规定，可执行程序本身的文件名也算一个命令行参数，因此argc值至少为1；
> - **argv:**

